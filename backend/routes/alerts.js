import express from 'express';
import { body, validationResult } from 'express-validator';
import Alert from '../models/Alert.js';
import Vehicle from '../models/Vehicle.js';
import Machinery from '../models/Machinery.js';
import Tool from '../models/Tool.js';
import Part from '../models/Part.js';
import { protect } from '../middleware/auth.js';

const router = express.Router();

// All routes are protected
router.use(protect);

// @desc    Get alert statistics
// @route   GET /api/alerts/stats
// @access  Private
router.get('/stats', async (req, res) => {
  try {
    console.log('Getting alert statistics for user:', req.user._id);
    
    const baseQuery = { createdBy: req.user._id };
    
    // Get alert counts by status
    const alertsByStatus = await Alert.aggregate([
      { $match: baseQuery },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 }
        }
      }
    ]);

    // Get alert counts by priority
    const alertsByPriority = await Alert.aggregate([
      { $match: { ...baseQuery, status: 'Activa' } },
      {
        $group: {
          _id: '$priority',
          count: { $sum: 1 }
        }
      }
    ]);

    // Get alert counts by type
    const alertsByType = await Alert.aggregate([
      { $match: { ...baseQuery, status: 'Activa' } },
      {
        $group: {
          _id: '$type',
          count: { $sum: 1 }
        }
      },
      { $sort: { count: -1 } }
    ]);

    // Get overdue alerts count
    const overdueAlerts = await Alert.countDocuments({
      ...baseQuery,
      status: 'Activa',
      dueDate: { $lt: new Date() }
    });

    const stats = {
      alertsByStatus: alertsByStatus.reduce((acc, item) => {
        acc[item._id] = item.count;
        return acc;
      }, { Activa: 0, Resuelta: 0, Descartada: 0 }),
      alertsByPriority: alertsByPriority.reduce((acc, item) => {
        acc[item._id] = item.count;
        return acc;
      }, { Baja: 0, Media: 0, Alta: 0, Crítica: 0 }),
      alertsByType,
      overdueAlerts,
      totalActive: alertsByStatus.find(item => item._id === 'Activa')?.count || 0
    };

    console.log('Alert statistics:', stats);

    res.status(200).json({
      success: true,
      data: stats
    });
  } catch (error) {
    console.error('Get alert statistics error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching alert statistics',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @desc    Generate automatic alerts
// @route   POST /api/alerts/generate
// @access  Private
router.post('/generate', async (req, res) => {
  try {
    console.log('Generating automatic alerts for user:', req.user._id);
    
    const generatedAlerts = [];
    const baseQuery = { createdBy: req.user._id };

    // Check vehicles for expired/expiring documents
    const vehicles = await Vehicle.find(baseQuery);
    for (const vehicle of vehicles) {
      const now = new Date();
      
      // Check SOAT expiration
      const soatDate = new Date(vehicle.soatExpiration);
      const soatDays = Math.ceil((soatDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      
      if (soatDays <= 30) {
        const existingAlert = await Alert.findOne({
          createdBy: req.user._id,
          sourceType: 'Vehicle',
          sourceId: vehicle._id,
          type: 'SOAT Vencido',
          status: 'Activa'
        });

        if (!existingAlert) {
          const alert = new Alert({
            title: `SOAT ${soatDays < 0 ? 'vencido' : 'por vencer'}`,
            description: `El SOAT del vehículo ${vehicle.plate} ${soatDays < 0 ? 'venció' : 'vence'} ${soatDays < 0 ? `hace ${Math.abs(soatDays)} días` : `en ${soatDays} días`}`,
            type: 'SOAT Vencido',
            priority: soatDays < 0 ? 'Crítica' : soatDays <= 7 ? 'Alta' : 'Media',
            sourceType: 'Vehicle',
            sourceId: vehicle._id,
            sourceName: `${vehicle.brand} ${vehicle.model} - ${vehicle.plate}`,
            dueDate: soatDate,
            autoGenerated: true,
            metadata: {
              expirationDate: soatDate,
              vehiclePlate: vehicle.plate
            },
            createdBy: req.user._id
          });
          
          await alert.save();
          generatedAlerts.push(alert);
        }
      }

      // Check Technical Review expiration
      const techDate = new Date(vehicle.technicalReviewExpiration);
      const techDays = Math.ceil((techDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      
      if (techDays <= 30) {
        const existingAlert = await Alert.findOne({
          createdBy: req.user._id,
          sourceType: 'Vehicle',
          sourceId: vehicle._id,
          type: 'Revisión Técnica',
          status: 'Activa'
        });

        if (!existingAlert) {
          const alert = new Alert({
            title: `Revisión Técnica ${techDays < 0 ? 'vencida' : 'por vencer'}`,
            description: `La revisión técnica del vehículo ${vehicle.plate} ${techDays < 0 ? 'venció' : 'vence'} ${techDays < 0 ? `hace ${Math.abs(techDays)} días` : `en ${techDays} días`}`,
            type: 'Revisión Técnica',
            priority: techDays < 0 ? 'Crítica' : techDays <= 7 ? 'Alta' : 'Media',
            sourceType: 'Vehicle',
            sourceId: vehicle._id,
            sourceName: `${vehicle.brand} ${vehicle.model} - ${vehicle.plate}`,
            dueDate: techDate,
            autoGenerated: true,
            metadata: {
              expirationDate: techDate,
              vehiclePlate: vehicle.plate
            },
            createdBy: req.user._id
          });
          
          await alert.save();
          generatedAlerts.push(alert);
        }
      }

      // Check for critical maintenance
      if (vehicle.pendingMaintenance && vehicle.pendingMaintenance.length > 0) {
        const criticalMaintenance = vehicle.pendingMaintenance.filter(m => m.priority === 'Crítica');
        
        for (const maintenance of criticalMaintenance) {
          const existingAlert = await Alert.findOne({
            createdBy: req.user._id,
            sourceType: 'Vehicle',
            sourceId: vehicle._id,
            type: 'Mantenimiento',
            status: 'Activa',
            description: { $regex: maintenance.description, $options: 'i' }
          });

          if (!existingAlert) {
            const alert = new Alert({
              title: 'Mantenimiento Crítico Pendiente',
              description: `El vehículo ${vehicle.plate} requiere mantenimiento crítico: ${maintenance.description}`,
              type: 'Mantenimiento',
              priority: 'Crítica',
              sourceType: 'Vehicle',
              sourceId: vehicle._id,
              sourceName: `${vehicle.brand} ${vehicle.model} - ${vehicle.plate}`,
              autoGenerated: true,
              metadata: {
                vehiclePlate: vehicle.plate
              },
              createdBy: req.user._id
            });
            
            await alert.save();
            generatedAlerts.push(alert);
          }
        }
      }
    }

    // Check parts for low/no stock
    const parts = await Part.find(baseQuery);
    for (const part of parts) {
      if (part.currentStock === 0) {
        const existingAlert = await Alert.findOne({
          createdBy: req.user._id,
          sourceType: 'Part',
          sourceId: part._id,
          type: 'Sin Stock',
          status: 'Activa'
        });

        if (!existingAlert) {
          const alert = new Alert({
            title: 'Repuesto Sin Stock',
            description: `El repuesto ${part.name} (${part.partNumber}) está sin stock`,
            type: 'Sin Stock',
            priority: 'Alta',
            sourceType: 'Part',
            sourceId: part._id,
            sourceName: `${part.name} - ${part.partNumber}`,
            autoGenerated: true,
            metadata: {
              currentStock: part.currentStock,
              minimumStock: part.minimumStock,
              partNumber: part.partNumber
            },
            createdBy: req.user._id
          });
          
          await alert.save();
          generatedAlerts.push(alert);
        }
      } else if (part.currentStock <= part.minimumStock) {
        const existingAlert = await Alert.findOne({
          createdBy: req.user._id,
          sourceType: 'Part',
          sourceId: part._id,
          type: 'Stock Bajo',
          status: 'Activa'
        });

        if (!existingAlert) {
          const alert = new Alert({
            title: 'Stock Bajo de Repuesto',
            description: `El repuesto ${part.name} (${part.partNumber}) tiene stock bajo: ${part.currentStock} ${part.unit} (mínimo: ${part.minimumStock})`,
            type: 'Stock Bajo',
            priority: 'Media',
            sourceType: 'Part',
            sourceId: part._id,
            sourceName: `${part.name} - ${part.partNumber}`,
            autoGenerated: true,
            metadata: {
              currentStock: part.currentStock,
              minimumStock: part.minimumStock,
              partNumber: part.partNumber
            },
            createdBy: req.user._id
          });
          
          await alert.save();
          generatedAlerts.push(alert);
        }
      }
    }

    // Check tools for damaged/lost status
    const tools = await Tool.find({ ...baseQuery, $or: [{ status: 'Dañada' }, { status: 'Perdida' }, { condition: 'Malo' }] });
    for (const tool of tools) {
      const existingAlert = await Alert.findOne({
        createdBy: req.user._id,
        sourceType: 'Tool',
        sourceId: tool._id,
        type: 'Herramienta Dañada',
        status: 'Activa'
      });

      if (!existingAlert) {
        const alert = new Alert({
          title: `Herramienta ${tool.status === 'Perdida' ? 'Perdida' : 'Dañada'}`,
          description: `La herramienta ${tool.name} ${tool.code ? `(${tool.code})` : ''} está ${tool.status === 'Perdida' ? 'perdida' : 'dañada o en mal estado'}`,
          type: 'Herramienta Dañada',
          priority: tool.status === 'Perdida' ? 'Alta' : 'Media',
          sourceType: 'Tool',
          sourceId: tool._id,
          sourceName: `${tool.name}${tool.code ? ` - ${tool.code}` : ''}`,
          autoGenerated: true,
          metadata: {
            toolCode: tool.code
          },
          createdBy: req.user._id
        });
        
        await alert.save();
        generatedAlerts.push(alert);
      }
    }

    // Check rentals for pending payments
    const rentals = await Rental.find({ ...baseQuery, paymentStatus: { $in: ['Pendiente', 'Parcial'] } })
      .populate('client', 'name company')
      .populate('equipment', 'brand model serialNumber');
    
    for (const rental of rentals) {
      const pendingAmount = rental.totalAmount - rental.paidAmount;
      const daysSinceEnd = Math.ceil((new Date().getTime() - new Date(rental.endDate).getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysSinceEnd > 7 && pendingAmount > 0) {
        const existingAlert = await Alert.findOne({
          createdBy: req.user._id,
          sourceType: 'Rental',
          sourceId: rental._id,
          type: 'Pago Pendiente',
          status: 'Activa'
        });

        if (!existingAlert) {
          const alert = new Alert({
            title: 'Pago Pendiente de Alquiler',
            description: `El alquiler de ${rental.equipment.brand} ${rental.equipment.model} para ${rental.client.name} tiene un pago pendiente de S/ ${pendingAmount.toFixed(2)}`,
            type: 'Pago Pendiente',
            priority: daysSinceEnd > 30 ? 'Alta' : 'Media',
            sourceType: 'Rental',
            sourceId: rental._id,
            sourceName: `Alquiler - ${rental.client.name}`,
            autoGenerated: true,
            metadata: {
              amount: pendingAmount
            },
            createdBy: req.user._id
          });
          
          await alert.save();
          generatedAlerts.push(alert);
        }
      }
    }

    console.log(`Generated ${generatedAlerts.length} automatic alerts`);

    res.status(200).json({
      success: true,
      message: `Se generaron ${generatedAlerts.length} alertas automáticas`,
      data: generatedAlerts
    });
  } catch (error) {
    console.error('Generate alerts error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while generating alerts',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @desc    Get all alerts
// @route   GET /api/alerts
// @access  Private
router.get('/', async (req, res) => {
  try {
    console.log('Getting all alerts for user:', req.user._id);
    console.log('Query parameters:', req.query);
    
    const { status, type, priority, search, page = 1, limit = 20 } = req.query;
    let query = { createdBy: req.user._id };

    // Add filters
    if (status && status !== 'all') {
      query.status = status;
    }
    if (type && type !== 'all') {
      query.type = type;
    }
    if (priority && priority !== 'all') {
      query.priority = priority;
    }
    if (search) {
      query.$or = [
        { title: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { sourceName: { $regex: search, $options: 'i' } }
      ];
    }

    console.log('Final query:', JSON.stringify(query, null, 2));

    // Calculate pagination
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;

    // Get total count for pagination
    const total = await Alert.countDocuments(query);
    
    // Get alerts with pagination
    const alerts = await Alert.find(query)
      .populate('createdBy', 'name email')
      .populate('resolvedBy', 'name email')
      .sort({ priority: -1, createdAt: -1 })
      .skip(skip)
      .limit(limitNum)
      .lean();

    console.log(`Found ${alerts.length} alerts (${total} total)`);

    res.status(200).json({
      success: true,
      count: alerts.length,
      total,
      page: pageNum,
      pages: Math.ceil(total / limitNum),
      data: alerts
    });
  } catch (error) {
    console.error('Get alerts error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching alerts',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @desc    Get single alert
// @route   GET /api/alerts/:id
// @access  Private
router.get('/:id', async (req, res) => {
  try {
    console.log('Getting alert with ID:', req.params.id);
    
    const alert = await Alert.findOne({
      _id: req.params.id,
      createdBy: req.user._id
    })
    .populate('createdBy', 'name email')
    .populate('resolvedBy', 'name email');

    if (!alert) {
      console.log('Alert not found');
      return res.status(404).json({
        success: false,
        message: 'Alert not found'
      });
    }

    console.log('Alert found:', alert._id);

    res.status(200).json({
      success: true,
      data: alert
    });
  } catch (error) {
    console.error('Get alert error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching alert',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @desc    Create new alert
// @route   POST /api/alerts
// @access  Private
router.post('/', [
  body('title')
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('Title is required and must be less than 100 characters'),
  body('description')
    .trim()
    .isLength({ min: 1, max: 500 })
    .withMessage('Description is required and must be less than 500 characters'),
  body('type')
    .isIn([
      'Mantenimiento', 'SOAT Vencido', 'Revisión Técnica', 'Stock Bajo', 'Sin Stock',
      'Herramienta Dañada', 'Vehículo Fuera de Servicio', 'Pago Pendiente',
      'Documento Vencido', 'Manual', 'Otro'
    ])
    .withMessage('Invalid alert type'),
  body('priority')
    .optional()
    .isIn(['Baja', 'Media', 'Alta', 'Crítica'])
    .withMessage('Invalid priority'),
  body('dueDate')
    .optional()
    .isISO8601()
    .withMessage('Valid due date is required')
], async (req, res) => {
  try {
    console.log('Creating new alert:', req.body);
    
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('Validation errors:', errors.array());
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    // Create alert
    const alertData = {
      ...req.body,
      sourceType: 'Manual',
      sourceName: req.body.sourceName || 'Alerta Manual',
      createdBy: req.user._id
    };

    console.log('Creating alert with data:', alertData);

    const alert = new Alert(alertData);
    const savedAlert = await alert.save();
    
    // Populate the created alert
    await savedAlert.populate('createdBy', 'name email');
    
    console.log('Alert created successfully:', savedAlert._id);

    res.status(201).json({
      success: true,
      data: savedAlert
    });
  } catch (error) {
    console.error('Create alert error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while creating alert',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @desc    Update alert
// @route   PUT /api/alerts/:id
// @access  Private
router.put('/:id', [
  body('title')
    .optional()
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('Title must be less than 100 characters'),
  body('description')
    .optional()
    .trim()
    .isLength({ min: 1, max: 500 })
    .withMessage('Description must be less than 500 characters'),
  body('type')
    .optional()
    .isIn([
      'Mantenimiento', 'SOAT Vencido', 'Revisión Técnica', 'Stock Bajo', 'Sin Stock',
      'Herramienta Dañada', 'Vehículo Fuera de Servicio', 'Pago Pendiente',
      'Documento Vencido', 'Manual', 'Otro'
    ])
    .withMessage('Invalid alert type'),
  body('priority')
    .optional()
    .isIn(['Baja', 'Media', 'Alta', 'Crítica'])
    .withMessage('Invalid priority'),
  body('status')
    .optional()
    .isIn(['Activa', 'Resuelta', 'Descartada'])
    .withMessage('Invalid status')
], async (req, res) => {
  try {
    console.log('Updating alert:', req.params.id, req.body);
    
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const updateData = { ...req.body };

    // If resolving the alert, add resolved date and user
    if (updateData.status === 'Resuelta' || updateData.status === 'Descartada') {
      updateData.resolvedDate = new Date();
      updateData.resolvedBy = req.user._id;
    }

    const alert = await Alert.findOneAndUpdate(
      { _id: req.params.id, createdBy: req.user._id },
      updateData,
      { new: true, runValidators: true }
    )
    .populate('createdBy', 'name email')
    .populate('resolvedBy', 'name email');

    if (!alert) {
      return res.status(404).json({
        success: false,
        message: 'Alert not found'
      });
    }

    console.log('Alert updated successfully');

    res.status(200).json({
      success: true,
      data: alert
    });
  } catch (error) {
    console.error('Update alert error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while updating alert',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @desc    Delete alert
// @route   DELETE /api/alerts/:id
// @access  Private
router.delete('/:id', async (req, res) => {
  try {
    console.log('Deleting alert:', req.params.id);
    
    const alert = await Alert.findOneAndDelete({
      _id: req.params.id,
      createdBy: req.user._id
    });

    if (!alert) {
      return res.status(404).json({
        success: false,
        message: 'Alert not found'
      });
    }

    console.log('Alert deleted successfully');

    res.status(200).json({
      success: true,
      message: 'Alert deleted successfully'
    });
  } catch (error) {
    console.error('Delete alert error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while deleting alert',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

export default router;